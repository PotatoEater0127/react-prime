"use strict";const index=()=>"const md5File = require('md5-file');\nconst path = require('path');\n\n// Ignore CSS styles imported on load\nconst ignoreStyles = require('ignore-styles');\nconst register = ignoreStyles.default;\n\n// When running locally these will load from a standard import\n// When running on the server, we want to load via their hashed version in the build folder\nconst extensions = ['.gif', '.jpeg', '.jpg', '.png', '.svg'];\n\n// Override the default style ignorer, also modifying all image requests\nregister(ignoreStyles.DEFAULT_EXTENSIONS, (mod, filename) => {\n  if (!extensions.find(f => filename.endsWith(f))) {\n    // If we find a style\n    return ignoreStyles.noOp();\n  }\n  const hash = md5File.sync(filename).slice(0, 8);\n  const bn = path.basename(filename).replace(/(\\.\\w{3})$/, `.${hash}$1`);\n  \n  mod.exports = `/static/media/${bn}`;\n});\n\n// require babel to transpile JSX\n// allow imports and code splitting through plugins\nrequire('babel-register')({\n  ignore: /\\/(build|node_modules)\\//,\n  presets: ['env', 'react-app'],\n  plugins: [\n    'syntax-dynamic-import',\n    'dynamic-import-node',\n    'react-loadable/babel'\n  ]\n});\n\n// import the server\nrequire('./server');";module.exports=index;const createCompareHTML=e=>`<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset="UTF-8">\n    <title>React Prime</title>\n    <style>\n      html, body {\n        margin: 0;\n        padding: 0;\n      }\n  \n      body {\n        background-color: white;\n      }\n  \n      p {\n        text-align: center;\n        font-family: Arial, Helvetica, sans-serif;\n      }\n  \n      #top-logo {\n        padding: 20px;\n        background-color: black;\n        margin: 0 auto;\n        width: 100%;\n      }\n  \n      #top-logo img {\n        margin-left: 2%;\n      }\n  \n      #iframe-wrapper {\n        margin-left: 4%;\n        margin-right: 4%;\n        margin-top: 10px;\n        width: 100%;\n      }\n  \n      #csr-div {\n        margin-right: 40px;\n      }\n  \n      #csr-div, #ssr-div {\n        margin-bottom: 20px;\n      }\n  \n      #csr-iframe,\n      #ssr-iframe {\n        width: 100%;\n        height: 420px;\n        border: 0px;\n        padding: 2px;\n        box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);\n      }\n  \n      #csr-report-iframe,\n      #ssr-report-iframe {\n        width: 100%;\n        height: 420px;\n      }\n  \n      #csr-div,\n      #ssr-div {\n        width: 44%;\n        float: left;\n      }\n  \n      #button1 {\n        text-align: center;\n      }\n  \n      #button2 {\n        text-align: center;\n      }\n  \n      .btn {\n        padding: 10px 25px;\n        font-size: 15px;\n        font-family: Arial, Helvetica, sans-serif;\n        text-decoration: none;\n        color: #fff;\n        position: relative;\n        border-left: 8px solid #4d1551;\n        cursor: pointer;\n        margin-top: 20px;\n        margin-bottom: 20px;\n        margin-left: auto;\n        margin-right: auto;\n        width: 130px;\n      }\n  \n      .purple {\n        background-color: #9b59b6;\n      }\n  \n      .purple:hover {\n        background-color: #B573D0;\n      }\n  </style>\n  </head>\n  <body>\n    <div id="top-logo"><img src="https://s3-us-west-1.amazonaws.com/reactprimeimages/primeLogo.png" width="200"></div>\n    <div id="iframe-wrapper">\n      <div id="csr-div">\n        <div>\n          <p>Client-Side Rendered</p>\n        </div>\n        <iframe id="csr-iframe" src="http://localhost:${e.port}"></iframe>\n        <div>\n          <div id="button1" class="btn purple" onClick='document.getElementById("csr-report-iframe").src="http://localhost:5050/csr-report";window.scrollBy(0, 600);' className="btn purple">VIEW\n            REPORT\n          </div>\n          <iframe id='csr-report-iframe' frameborder="0"></iframe>\n        </div>\n      </div>\n      <div id="ssr-div">\n        <div>\n          <p>Server-Side Rendered</p>\n        </div>\n        <iframe id="ssr-iframe" src="http://localhost:8080"></iframe>\n        <div>\n          <div id="button2" class="btn purple" onClick='document.getElementById("ssr-report-iframe").src="http://localhost:5050/ssr-report";window.scrollBy(0, 600);' className="btn purple">VIEW\n            REPORT\n          </div>\n          <iframe id='ssr-report-iframe' frameborder="0"></iframe>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>`;module.exports=createCompareHTML;const createConfig=()=>"module.exports = {\n  extends: 'lighthouse:default',\n  settings: {\n    throttlingMethod: 'devtools',\n    onlyCategories: ['performance'],\n  },\n};";module.exports=createConfig;const createPrimeServer=()=>"const express = require('express');\nconst path = require('path');\n\nconst app = express();\n\nconst port = 5050;\n\napp.use('/csr-report', express.static(path.join(__dirname, './reports/csr-report.html')));\napp.use('/ssr-report', express.static(path.join(__dirname, './reports/ssr-report.html')));\n\napp.get('/', (req, res) => {\n  res.sendFile(path.join(__dirname, './primeCompare.html'));\n});\napp.listen(port, () => console.log('Listening on port 5050, ready to compare'));\n";module.exports=createPrimeServer;const returnHTML=e=>`// standard react modules\nimport React from 'react';\nimport { renderToString } from 'react-dom/server';\n// security middleware\nimport Helmet from 'react-helmet';\n// required for react router\nimport { StaticRouter } from 'react-router';\n// frontload helps when trying to render react components that need to\n// retrieve data asynchronously\nimport { Frontload, frontloadServerRender } from 'react-frontload';\nimport Loadable from 'react-loadable';\nimport path from 'path';\nimport fs from 'fs';\n\n// main entrypoint and manifest (included in CRA)\nimport App from '../${e.component}';\nimport manifest from '../build/asset-manifest.json';\n\n// export middleware that returns stringified HTML from server\nconst returnHTML = (req, res) => {\n  const injectHTML = (data, { html, title, meta, body, scripts }) => {\n    data = data.replace('<html>', \`<html \${html}>\`);\n    data = data.replace(/<title>.*?<\\/title>/g, title);\n    data = data.replace('</head>', \`\${meta}</head>\`);\n    data = data.replace(\n      '<div id="root"></div>',\n      \`<div id="root">\${body}</div>\`\n    );\n    data = data.replace('</body>', scripts.join('') + '</body>');\n\n    return data;\n  };\n\n  fs.readFile(\n    path.resolve(__dirname, '../${e.rootHtml}'),\n    'utf8',\n    (err, htmlData) => {\n      if (err) {\n        console.error('Read error', err);\n        return res.status(404).end();\n      }\n\n      // define context for react router\n      const context = {};\n      // define modules for react loadable\n      const modules = [];\n\n      frontloadServerRender(() =>\n        renderToString(\n          <Loadable.Capture report={m => modules.push(m)}>\n            <StaticRouter location={req.url} context={context}>\n              <Frontload isServer>\n                <App />\n              </Frontload>\n            </StaticRouter>\n          </Loadable.Capture>\n        )\n      ).then(routeMarkup => {\n        if (context.url) {\n          // If context has a url property, then we need to handle a redirection in Redux Router\n          res.writeHead(302, {\n            Location: context.url\n          });\n\n          res.end();\n        } else {\n          // Otherwise, we carry on...\n\n          // Let's give ourself a function to load all our page-specific JS assets for code splitting\n          const extractAssets = (assets, chunks) =>\n            Object.keys(assets)\n              .filter(asset => chunks.indexOf(asset.replace('.js', '')) > -1)\n              .map(k => assets[k]);\n\n          // Let's format those assets into pretty <script> tags\n          const extraChunks = extractAssets(manifest, modules).map(\n            c => \`<script type="text/javascript" src="/\${c}"><\/script>\`\n          );\n\n          // We need to tell Helmet to compute the right meta tags, title, and such\n          const helmet = Helmet.renderStatic();\n\n          // Pass all this nonsense into our HTML formatting function above\n          const html = injectHTML(htmlData, {\n            html: helmet.htmlAttributes.toString(),\n            title: helmet.title.toString(),\n            meta: helmet.meta.toString(),\n            body: routeMarkup,\n            scripts: extraChunks\n          });\n\n          // We have all the final HTML, let's send it to the user already!\n          res.status(200).send(html);\n        }\n      });\n    }\n  );\n}\nexport default returnHTML`;module.exports=returnHTML;const server=e=>`const express = require('express');\nconst bodyParser = require('body-parser');\nconst path = require('path');\nconst compression = require('compression');\nconst Loadable = require('react-loadable');\n\n// import middleware to return HTML on server request\nimport returnHTML from './returnHTML';\n\nconst app = express();\nconst PORT = 8080;\n\n// apply middleware\napp.use(compression());\napp.use(bodyParser.json());\napp.use(bodyParser.urlencoded({ extended: false }));\n\n/*\n  NOTE: captures all routes and returns the user's HTML \n        (may not be ideal for non-SPAs)\n*/\napp.use(express.Router().get('/', returnHTML));\napp.use(express.static(path.resolve(__dirname, \`../${e.static}\`)));\napp.use(returnHTML);\n\nLoadable.preloadAll().then(() => {\n  app.listen(PORT, () => {\n    console.log(\`Listening on \${PORT}...\`);\n  });\n});\n\napp.on('error', (err) => {\n  if (err) {\n    console.log(\`Error: \${error}\`);\n    throw err;\n  }\n});`;module.exports=server;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJsaWIvaW5kZXguanMiLCJsaWIvcGVyZm9ybWFuY2VUZXN0L2NyZWF0ZUNvbXBhcmVIVE1MLmpzIiwibGliL3BlcmZvcm1hbmNlVGVzdC9jcmVhdGVDb25maWcuanMiLCJsaWIvcGVyZm9ybWFuY2VUZXN0L2NyZWF0ZVByaW1lU2VydmVyLmpzIiwibGliL3JldHVybkhUTUwuanMiLCJsaWIvc2VydmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIHRvIG1ha2UgYW4gaW5kZXggZmlsZSBmb3IgdGhlIFNTUiB2ZXJzaW9uIG9mIHRoZSB1c2VyJ3MgYXBwXG4gKi9cblxuY29uc3QgaW5kZXggPSAoKSA9PiB7XG5yZXR1cm4gYGNvbnN0IG1kNUZpbGUgPSByZXF1aXJlKCdtZDUtZmlsZScpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcblxuLy8gSWdub3JlIENTUyBzdHlsZXMgaW1wb3J0ZWQgb24gbG9hZFxuY29uc3QgaWdub3JlU3R5bGVzID0gcmVxdWlyZSgnaWdub3JlLXN0eWxlcycpO1xuY29uc3QgcmVnaXN0ZXIgPSBpZ25vcmVTdHlsZXMuZGVmYXVsdDtcblxuLy8gV2hlbiBydW5uaW5nIGxvY2FsbHkgdGhlc2Ugd2lsbCBsb2FkIGZyb20gYSBzdGFuZGFyZCBpbXBvcnRcbi8vIFdoZW4gcnVubmluZyBvbiB0aGUgc2VydmVyLCB3ZSB3YW50IHRvIGxvYWQgdmlhIHRoZWlyIGhhc2hlZCB2ZXJzaW9uIGluIHRoZSBidWlsZCBmb2xkZXJcbmNvbnN0IGV4dGVuc2lvbnMgPSBbJy5naWYnLCAnLmpwZWcnLCAnLmpwZycsICcucG5nJywgJy5zdmcnXTtcblxuLy8gT3ZlcnJpZGUgdGhlIGRlZmF1bHQgc3R5bGUgaWdub3JlciwgYWxzbyBtb2RpZnlpbmcgYWxsIGltYWdlIHJlcXVlc3RzXG5yZWdpc3RlcihpZ25vcmVTdHlsZXMuREVGQVVMVF9FWFRFTlNJT05TLCAobW9kLCBmaWxlbmFtZSkgPT4ge1xuICBpZiAoIWV4dGVuc2lvbnMuZmluZChmID0+IGZpbGVuYW1lLmVuZHNXaXRoKGYpKSkge1xuICAgIC8vIElmIHdlIGZpbmQgYSBzdHlsZVxuICAgIHJldHVybiBpZ25vcmVTdHlsZXMubm9PcCgpO1xuICB9XG4gIGNvbnN0IGhhc2ggPSBtZDVGaWxlLnN5bmMoZmlsZW5hbWUpLnNsaWNlKDAsIDgpO1xuICBjb25zdCBibiA9IHBhdGguYmFzZW5hbWUoZmlsZW5hbWUpLnJlcGxhY2UoLyhcXFxcLlxcXFx3ezN9KSQvLCBcXGAuXFwke2hhc2h9JDFcXGApO1xuICBcbiAgbW9kLmV4cG9ydHMgPSBcXGAvc3RhdGljL21lZGlhL1xcJHtibn1cXGA7XG59KTtcblxuLy8gcmVxdWlyZSBiYWJlbCB0byB0cmFuc3BpbGUgSlNYXG4vLyBhbGxvdyBpbXBvcnRzIGFuZCBjb2RlIHNwbGl0dGluZyB0aHJvdWdoIHBsdWdpbnNcbnJlcXVpcmUoJ2JhYmVsLXJlZ2lzdGVyJykoe1xuICBpZ25vcmU6IC9cXFxcLyhidWlsZHxub2RlX21vZHVsZXMpXFxcXC8vLFxuICBwcmVzZXRzOiBbJ2VudicsICdyZWFjdC1hcHAnXSxcbiAgcGx1Z2luczogW1xuICAgICdzeW50YXgtZHluYW1pYy1pbXBvcnQnLFxuICAgICdkeW5hbWljLWltcG9ydC1ub2RlJyxcbiAgICAncmVhY3QtbG9hZGFibGUvYmFiZWwnXG4gIF1cbn0pO1xuXG4vLyBpbXBvcnQgdGhlIHNlcnZlclxucmVxdWlyZSgnLi9zZXJ2ZXInKTtgO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbmRleDtcbiIsIi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIHRvIGNyZWF0ZSBhbiBIVE1MIGNvbXBhcmlzb24gZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gT2JqZWN0IGNvbnRhaW5pbmcgdXNlciBpbnB1dCBmcm9tIENMSSAocmVxdWlyZXMgdGhlIC5wb3J0IHByb3BlcnR5KVxuICovXG5cbmNvbnN0IGNyZWF0ZUNvbXBhcmVIVE1MID0gKGlucHV0KSA9PiB7XG5yZXR1cm4gYDwhRE9DVFlQRSBodG1sPlxuPGh0bWw+XG4gIDxoZWFkPlxuICAgIDxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiPlxuICAgIDx0aXRsZT5SZWFjdCBQcmltZTwvdGl0bGU+XG4gICAgPHN0eWxlPlxuICAgICAgaHRtbCwgYm9keSB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgIH1cbiAgXG4gICAgICBib2R5IHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICB9XG4gIFxuICAgICAgcCB7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XG4gICAgICB9XG4gIFxuICAgICAgI3RvcC1sb2dvIHtcbiAgICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XG4gICAgICAgIG1hcmdpbjogMCBhdXRvO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgIH1cbiAgXG4gICAgICAjdG9wLWxvZ28gaW1nIHtcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDIlO1xuICAgICAgfVxuICBcbiAgICAgICNpZnJhbWUtd3JhcHBlciB7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiA0JTtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiA0JTtcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICB9XG4gIFxuICAgICAgI2Nzci1kaXYge1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDQwcHg7XG4gICAgICB9XG4gIFxuICAgICAgI2Nzci1kaXYsICNzc3ItZGl2IHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjBweDtcbiAgICAgIH1cbiAgXG4gICAgICAjY3NyLWlmcmFtZSxcbiAgICAgICNzc3ItaWZyYW1lIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogNDIwcHg7XG4gICAgICAgIGJvcmRlcjogMHB4O1xuICAgICAgICBwYWRkaW5nOiAycHg7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDhweCAwIHJnYmEoMCwgMCwgMCwgMC4yKSwgMCA2cHggMjBweCAwIHJnYmEoMCwgMCwgMCwgMC4xOSk7XG4gICAgICB9XG4gIFxuICAgICAgI2Nzci1yZXBvcnQtaWZyYW1lLFxuICAgICAgI3Nzci1yZXBvcnQtaWZyYW1lIHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogNDIwcHg7XG4gICAgICB9XG4gIFxuICAgICAgI2Nzci1kaXYsXG4gICAgICAjc3NyLWRpdiB7XG4gICAgICAgIHdpZHRoOiA0NCU7XG4gICAgICAgIGZsb2F0OiBsZWZ0O1xuICAgICAgfVxuICBcbiAgICAgICNidXR0b24xIHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgfVxuICBcbiAgICAgICNidXR0b24yIHtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgfVxuICBcbiAgICAgIC5idG4ge1xuICAgICAgICBwYWRkaW5nOiAxMHB4IDI1cHg7XG4gICAgICAgIGZvbnQtc2l6ZTogMTVweDtcbiAgICAgICAgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7XG4gICAgICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcbiAgICAgICAgY29sb3I6ICNmZmY7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYm9yZGVyLWxlZnQ6IDhweCBzb2xpZCAjNGQxNTUxO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIG1hcmdpbi10b3A6IDIwcHg7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XG4gICAgICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IGF1dG87XG4gICAgICAgIHdpZHRoOiAxMzBweDtcbiAgICAgIH1cbiAgXG4gICAgICAucHVycGxlIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzliNTliNjtcbiAgICAgIH1cbiAgXG4gICAgICAucHVycGxlOmhvdmVyIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI0I1NzNEMDtcbiAgICAgIH1cbiAgPC9zdHlsZT5cbiAgPC9oZWFkPlxuICA8Ym9keT5cbiAgICA8ZGl2IGlkPVwidG9wLWxvZ29cIj48aW1nIHNyYz1cImh0dHBzOi8vczMtdXMtd2VzdC0xLmFtYXpvbmF3cy5jb20vcmVhY3RwcmltZWltYWdlcy9wcmltZUxvZ28ucG5nXCIgd2lkdGg9XCIyMDBcIj48L2Rpdj5cbiAgICA8ZGl2IGlkPVwiaWZyYW1lLXdyYXBwZXJcIj5cbiAgICAgIDxkaXYgaWQ9XCJjc3ItZGl2XCI+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPHA+Q2xpZW50LVNpZGUgUmVuZGVyZWQ8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aWZyYW1lIGlkPVwiY3NyLWlmcmFtZVwiIHNyYz1cImh0dHA6Ly9sb2NhbGhvc3Q6JHtpbnB1dC5wb3J0fVwiPjwvaWZyYW1lPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxkaXYgaWQ9XCJidXR0b24xXCIgY2xhc3M9XCJidG4gcHVycGxlXCIgb25DbGljaz0nZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjc3ItcmVwb3J0LWlmcmFtZVwiKS5zcmM9XCJodHRwOi8vbG9jYWxob3N0OjUwNTAvY3NyLXJlcG9ydFwiO3dpbmRvdy5zY3JvbGxCeSgwLCA2MDApOycgY2xhc3NOYW1lPVwiYnRuIHB1cnBsZVwiPlZJRVdcbiAgICAgICAgICAgIFJFUE9SVFxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxpZnJhbWUgaWQ9J2Nzci1yZXBvcnQtaWZyYW1lJyBmcmFtZWJvcmRlcj1cIjBcIj48L2lmcmFtZT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgaWQ9XCJzc3ItZGl2XCI+XG4gICAgICAgIDxkaXY+XG4gICAgICAgICAgPHA+U2VydmVyLVNpZGUgUmVuZGVyZWQ8L3A+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8aWZyYW1lIGlkPVwic3NyLWlmcmFtZVwiIHNyYz1cImh0dHA6Ly9sb2NhbGhvc3Q6ODA4MFwiPjwvaWZyYW1lPlxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxkaXYgaWQ9XCJidXR0b24yXCIgY2xhc3M9XCJidG4gcHVycGxlXCIgb25DbGljaz0nZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzc3ItcmVwb3J0LWlmcmFtZVwiKS5zcmM9XCJodHRwOi8vbG9jYWxob3N0OjUwNTAvc3NyLXJlcG9ydFwiO3dpbmRvdy5zY3JvbGxCeSgwLCA2MDApOycgY2xhc3NOYW1lPVwiYnRuIHB1cnBsZVwiPlZJRVdcbiAgICAgICAgICAgIFJFUE9SVFxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxpZnJhbWUgaWQ9J3Nzci1yZXBvcnQtaWZyYW1lJyBmcmFtZWJvcmRlcj1cIjBcIj48L2lmcmFtZT5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9ib2R5PlxuPC9odG1sPmA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNvbXBhcmVIVE1MO1xuIiwiLyoqXG4gKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmcgdG8gY3JlYXRlIGEgR29vZ2xlIExpZ2h0aG91c2UgY29uZmlnIGZpbGVcbiAqL1xuXG5jb25zdCBjcmVhdGVDb25maWcgPSAoKSA9PiB7XG5yZXR1cm4gYG1vZHVsZS5leHBvcnRzID0ge1xuICBleHRlbmRzOiAnbGlnaHRob3VzZTpkZWZhdWx0JyxcbiAgc2V0dGluZ3M6IHtcbiAgICB0aHJvdHRsaW5nTWV0aG9kOiAnZGV2dG9vbHMnLFxuICAgIG9ubHlDYXRlZ29yaWVzOiBbJ3BlcmZvcm1hbmNlJ10sXG4gIH0sXG59O2A7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNvbmZpZztcbiIsIi8qKlxuICogRnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIHRvIGNyZWF0ZSBhIHNlcnZlciBmaWxlIGZvciB0aGUgcHJpbWU6Y29tcGFyZSBucG0gc2NyaXB0XG4gKi9cblxuY29uc3QgY3JlYXRlUHJpbWVTZXJ2ZXIgPSAoKSA9PiB7XG5yZXR1cm4gYGNvbnN0IGV4cHJlc3MgPSByZXF1aXJlKCdleHByZXNzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5jb25zdCBhcHAgPSBleHByZXNzKCk7XG5cbmNvbnN0IHBvcnQgPSA1MDUwO1xuXG5hcHAudXNlKCcvY3NyLXJlcG9ydCcsIGV4cHJlc3Muc3RhdGljKHBhdGguam9pbihfX2Rpcm5hbWUsICcuL3JlcG9ydHMvY3NyLXJlcG9ydC5odG1sJykpKTtcbmFwcC51c2UoJy9zc3ItcmVwb3J0JywgZXhwcmVzcy5zdGF0aWMocGF0aC5qb2luKF9fZGlybmFtZSwgJy4vcmVwb3J0cy9zc3ItcmVwb3J0Lmh0bWwnKSkpO1xuXG5hcHAuZ2V0KCcvJywgKHJlcSwgcmVzKSA9PiB7XG4gIHJlcy5zZW5kRmlsZShwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi9wcmltZUNvbXBhcmUuaHRtbCcpKTtcbn0pO1xuYXBwLmxpc3Rlbihwb3J0LCAoKSA9PiBjb25zb2xlLmxvZygnTGlzdGVuaW5nIG9uIHBvcnQgNTA1MCwgcmVhZHkgdG8gY29tcGFyZScpKTtcbmA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVByaW1lU2VydmVyO1xuIiwiLyoqXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dCAtIE9iamVjdCBjb250YWluaW5nIHVzZXIgaW5wdXQgZnJvbSBDTElcbiAqIChyZXF1aXJlcyB0aGUgLmNvbXBvbmVudCBhbmQgLnJvb3RIVE1MIHByb3BlcnRpZXMpXG4gKi9cblxuY29uc3QgcmV0dXJuSFRNTCA9IChpbnB1dCkgPT4ge1xucmV0dXJuIGAvLyBzdGFuZGFyZCByZWFjdCBtb2R1bGVzXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVuZGVyVG9TdHJpbmcgfSBmcm9tICdyZWFjdC1kb20vc2VydmVyJztcbi8vIHNlY3VyaXR5IG1pZGRsZXdhcmVcbmltcG9ydCBIZWxtZXQgZnJvbSAncmVhY3QtaGVsbWV0Jztcbi8vIHJlcXVpcmVkIGZvciByZWFjdCByb3V0ZXJcbmltcG9ydCB7IFN0YXRpY1JvdXRlciB9IGZyb20gJ3JlYWN0LXJvdXRlcic7XG4vLyBmcm9udGxvYWQgaGVscHMgd2hlbiB0cnlpbmcgdG8gcmVuZGVyIHJlYWN0IGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvXG4vLyByZXRyaWV2ZSBkYXRhIGFzeW5jaHJvbm91c2x5XG5pbXBvcnQgeyBGcm9udGxvYWQsIGZyb250bG9hZFNlcnZlclJlbmRlciB9IGZyb20gJ3JlYWN0LWZyb250bG9hZCc7XG5pbXBvcnQgTG9hZGFibGUgZnJvbSAncmVhY3QtbG9hZGFibGUnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuXG4vLyBtYWluIGVudHJ5cG9pbnQgYW5kIG1hbmlmZXN0IChpbmNsdWRlZCBpbiBDUkEpXG5pbXBvcnQgQXBwIGZyb20gJy4uLyR7aW5wdXQuY29tcG9uZW50fSc7XG5pbXBvcnQgbWFuaWZlc3QgZnJvbSAnLi4vYnVpbGQvYXNzZXQtbWFuaWZlc3QuanNvbic7XG5cbi8vIGV4cG9ydCBtaWRkbGV3YXJlIHRoYXQgcmV0dXJucyBzdHJpbmdpZmllZCBIVE1MIGZyb20gc2VydmVyXG5jb25zdCByZXR1cm5IVE1MID0gKHJlcSwgcmVzKSA9PiB7XG4gIGNvbnN0IGluamVjdEhUTUwgPSAoZGF0YSwgeyBodG1sLCB0aXRsZSwgbWV0YSwgYm9keSwgc2NyaXB0cyB9KSA9PiB7XG4gICAgZGF0YSA9IGRhdGEucmVwbGFjZSgnPGh0bWw+JywgXFxgPGh0bWwgXFwke2h0bWx9PlxcYCk7XG4gICAgZGF0YSA9IGRhdGEucmVwbGFjZSgvPHRpdGxlPi4qPzxcXFxcL3RpdGxlPi9nLCB0aXRsZSk7XG4gICAgZGF0YSA9IGRhdGEucmVwbGFjZSgnPC9oZWFkPicsIFxcYFxcJHttZXRhfTwvaGVhZD5cXGApO1xuICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoXG4gICAgICAnPGRpdiBpZD1cInJvb3RcIj48L2Rpdj4nLFxuICAgICAgXFxgPGRpdiBpZD1cInJvb3RcIj5cXCR7Ym9keX08L2Rpdj5cXGBcbiAgICApO1xuICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoJzwvYm9keT4nLCBzY3JpcHRzLmpvaW4oJycpICsgJzwvYm9keT4nKTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIGZzLnJlYWRGaWxlKFxuICAgIHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsICcuLi8ke2lucHV0LnJvb3RIdG1sfScpLFxuICAgICd1dGY4JyxcbiAgICAoZXJyLCBodG1sRGF0YSkgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdSZWFkIGVycm9yJywgZXJyKTtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA0KS5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVmaW5lIGNvbnRleHQgZm9yIHJlYWN0IHJvdXRlclxuICAgICAgY29uc3QgY29udGV4dCA9IHt9O1xuICAgICAgLy8gZGVmaW5lIG1vZHVsZXMgZm9yIHJlYWN0IGxvYWRhYmxlXG4gICAgICBjb25zdCBtb2R1bGVzID0gW107XG5cbiAgICAgIGZyb250bG9hZFNlcnZlclJlbmRlcigoKSA9PlxuICAgICAgICByZW5kZXJUb1N0cmluZyhcbiAgICAgICAgICA8TG9hZGFibGUuQ2FwdHVyZSByZXBvcnQ9e20gPT4gbW9kdWxlcy5wdXNoKG0pfT5cbiAgICAgICAgICAgIDxTdGF0aWNSb3V0ZXIgbG9jYXRpb249e3JlcS51cmx9IGNvbnRleHQ9e2NvbnRleHR9PlxuICAgICAgICAgICAgICA8RnJvbnRsb2FkIGlzU2VydmVyPlxuICAgICAgICAgICAgICAgIDxBcHAgLz5cbiAgICAgICAgICAgICAgPC9Gcm9udGxvYWQ+XG4gICAgICAgICAgICA8L1N0YXRpY1JvdXRlcj5cbiAgICAgICAgICA8L0xvYWRhYmxlLkNhcHR1cmU+XG4gICAgICAgIClcbiAgICAgICkudGhlbihyb3V0ZU1hcmt1cCA9PiB7XG4gICAgICAgIGlmIChjb250ZXh0LnVybCkge1xuICAgICAgICAgIC8vIElmIGNvbnRleHQgaGFzIGEgdXJsIHByb3BlcnR5LCB0aGVuIHdlIG5lZWQgdG8gaGFuZGxlIGEgcmVkaXJlY3Rpb24gaW4gUmVkdXggUm91dGVyXG4gICAgICAgICAgcmVzLndyaXRlSGVhZCgzMDIsIHtcbiAgICAgICAgICAgIExvY2F0aW9uOiBjb250ZXh0LnVybFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgY2Fycnkgb24uLi5cblxuICAgICAgICAgIC8vIExldCdzIGdpdmUgb3Vyc2VsZiBhIGZ1bmN0aW9uIHRvIGxvYWQgYWxsIG91ciBwYWdlLXNwZWNpZmljIEpTIGFzc2V0cyBmb3IgY29kZSBzcGxpdHRpbmdcbiAgICAgICAgICBjb25zdCBleHRyYWN0QXNzZXRzID0gKGFzc2V0cywgY2h1bmtzKSA9PlxuICAgICAgICAgICAgT2JqZWN0LmtleXMoYXNzZXRzKVxuICAgICAgICAgICAgICAuZmlsdGVyKGFzc2V0ID0+IGNodW5rcy5pbmRleE9mKGFzc2V0LnJlcGxhY2UoJy5qcycsICcnKSkgPiAtMSlcbiAgICAgICAgICAgICAgLm1hcChrID0+IGFzc2V0c1trXSk7XG5cbiAgICAgICAgICAvLyBMZXQncyBmb3JtYXQgdGhvc2UgYXNzZXRzIGludG8gcHJldHR5IDxzY3JpcHQ+IHRhZ3NcbiAgICAgICAgICBjb25zdCBleHRyYUNodW5rcyA9IGV4dHJhY3RBc3NldHMobWFuaWZlc3QsIG1vZHVsZXMpLm1hcChcbiAgICAgICAgICAgIGMgPT4gXFxgPHNjcmlwdCB0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCIgc3JjPVwiL1xcJHtjfVwiPjwvc2NyaXB0PlxcYFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRlbGwgSGVsbWV0IHRvIGNvbXB1dGUgdGhlIHJpZ2h0IG1ldGEgdGFncywgdGl0bGUsIGFuZCBzdWNoXG4gICAgICAgICAgY29uc3QgaGVsbWV0ID0gSGVsbWV0LnJlbmRlclN0YXRpYygpO1xuXG4gICAgICAgICAgLy8gUGFzcyBhbGwgdGhpcyBub25zZW5zZSBpbnRvIG91ciBIVE1MIGZvcm1hdHRpbmcgZnVuY3Rpb24gYWJvdmVcbiAgICAgICAgICBjb25zdCBodG1sID0gaW5qZWN0SFRNTChodG1sRGF0YSwge1xuICAgICAgICAgICAgaHRtbDogaGVsbWV0Lmh0bWxBdHRyaWJ1dGVzLnRvU3RyaW5nKCksXG4gICAgICAgICAgICB0aXRsZTogaGVsbWV0LnRpdGxlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBtZXRhOiBoZWxtZXQubWV0YS50b1N0cmluZygpLFxuICAgICAgICAgICAgYm9keTogcm91dGVNYXJrdXAsXG4gICAgICAgICAgICBzY3JpcHRzOiBleHRyYUNodW5rc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gV2UgaGF2ZSBhbGwgdGhlIGZpbmFsIEhUTUwsIGxldCdzIHNlbmQgaXQgdG8gdGhlIHVzZXIgYWxyZWFkeSFcbiAgICAgICAgICByZXMuc3RhdHVzKDIwMCkuc2VuZChodG1sKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICApO1xufVxuZXhwb3J0IGRlZmF1bHQgcmV0dXJuSFRNTGA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJldHVybkhUTUw7XG4iLCIvKipcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IC0gT2JqZWN0IGNvbnRhaW5pbmcgdXNlciBpbnB1dCBmcm9tIENMSSAocmVxdWlyZXMgdGhlIC5zdGF0aWMgcHJvcGVydHkpXG4gKi9cblxuY29uc3Qgc2VydmVyID0gKGlucHV0KSA9PiB7XG5yZXR1cm4gYGNvbnN0IGV4cHJlc3MgPSByZXF1aXJlKCdleHByZXNzJyk7XG5jb25zdCBib2R5UGFyc2VyID0gcmVxdWlyZSgnYm9keS1wYXJzZXInKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBjb21wcmVzc2lvbiA9IHJlcXVpcmUoJ2NvbXByZXNzaW9uJyk7XG5jb25zdCBMb2FkYWJsZSA9IHJlcXVpcmUoJ3JlYWN0LWxvYWRhYmxlJyk7XG5cbi8vIGltcG9ydCBtaWRkbGV3YXJlIHRvIHJldHVybiBIVE1MIG9uIHNlcnZlciByZXF1ZXN0XG5pbXBvcnQgcmV0dXJuSFRNTCBmcm9tICcuL3JldHVybkhUTUwnO1xuXG5jb25zdCBhcHAgPSBleHByZXNzKCk7XG5jb25zdCBQT1JUID0gODA4MDtcblxuLy8gYXBwbHkgbWlkZGxld2FyZVxuYXBwLnVzZShjb21wcmVzc2lvbigpKTtcbmFwcC51c2UoYm9keVBhcnNlci5qc29uKCkpO1xuYXBwLnVzZShib2R5UGFyc2VyLnVybGVuY29kZWQoeyBleHRlbmRlZDogZmFsc2UgfSkpO1xuXG4vKlxuICBOT1RFOiBjYXB0dXJlcyBhbGwgcm91dGVzIGFuZCByZXR1cm5zIHRoZSB1c2VyJ3MgSFRNTCBcbiAgICAgICAgKG1heSBub3QgYmUgaWRlYWwgZm9yIG5vbi1TUEFzKVxuKi9cbmFwcC51c2UoZXhwcmVzcy5Sb3V0ZXIoKS5nZXQoJy8nLCByZXR1cm5IVE1MKSk7XG5hcHAudXNlKGV4cHJlc3Muc3RhdGljKHBhdGgucmVzb2x2ZShfX2Rpcm5hbWUsIFxcYC4uLyR7aW5wdXQuc3RhdGljfVxcYCkpKTtcbmFwcC51c2UocmV0dXJuSFRNTCk7XG5cbkxvYWRhYmxlLnByZWxvYWRBbGwoKS50aGVuKCgpID0+IHtcbiAgYXBwLmxpc3RlbihQT1JULCAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXFxgTGlzdGVuaW5nIG9uIFxcJHtQT1JUfS4uLlxcYCk7XG4gIH0pO1xufSk7XG5cbmFwcC5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gIGlmIChlcnIpIHtcbiAgICBjb25zb2xlLmxvZyhcXGBFcnJvcjogXFwke2Vycm9yfVxcYCk7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59KTtgO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXJ2ZXI7XG4iXSwibmFtZXMiOlsiaW5kZXgiLCJtb2R1bGUiLCJleHBvcnRzIiwiY3JlYXRlQ29tcGFyZUhUTUwiLCJpbnB1dCIsInBvcnQiLCJjcmVhdGVDb25maWciLCJjcmVhdGVQcmltZVNlcnZlciIsInJldHVybkhUTUwiLCJjb21wb25lbnQiLCJyb290SHRtbCIsInNlcnZlciIsInN0YXRpYyJdLCJtYXBwaW5ncyI6ImFBSUEsTUFBTUEsTUFBUSxJQUNQLHdyQ0F1Q1BDLE9BQU9DLFFBQVVGLE1DdkNqQixNQUFNRyxrQkFBcUJDLDh0RUE0RzZCQSxFQUFNQyw2NEJBeUI5REosT0FBT0MsUUFBVUMsa0JDdElqQixNQUFNRyxhQUFlLElBQ2QseUpBU1BMLE9BQU9DLFFBQVVJLGFDVmpCLE1BQU1DLGtCQUFvQixJQUNuQixzZUFpQlBOLE9BQU9DLFFBQVVLLGtCQ2hCakIsTUFBTUMsV0FBY0osd2tCQWdCRUEsRUFBTUssMnBCQW1CTUwsRUFBTU0sOG5FQW1FeENULE9BQU9DLFFBQVVNLFdDdkdqQixNQUFNRyxPQUFVUCxvckJBdUJzQ0EsRUFBTVEsaVJBaUI1RFgsT0FBT0MsUUFBVVMifQ==
